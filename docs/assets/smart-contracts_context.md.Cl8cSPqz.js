import{_ as n,c as e,j as s,a as t,t as i,a1 as h,o as l}from"./chunks/framework.DSxiLPfT.js";const F=JSON.parse('{"title":"Context","description":"Execution Context in Contracting.","frontmatter":{"title":"Context","description":"Execution Context in Contracting."},"headers":[],"relativePath":"smart-contracts/context.md","filePath":"smart-contracts/context.md"}'),o={name:"smart-contracts/context.md"},p={id:"frontmatter-title",tabindex:"-1"},c=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),r={id:"frontmatter-description",tabindex:"-1"},d=s("a",{class:"header-anchor",href:"#frontmatter-description","aria-label":'Permalink to "{{$frontmatter.description}}"'},"​",-1),k=h(`<p>When you are running a contract, you often want to know who is running it. For example, if someone who isn&#39;t an account owner tries to spend their money, you need to have some way of identifying who that person is and prevent that from happening. This is where Context, or <code>ctx</code> inside of smart contracts, comes into play.</p><p>There are six types of <code>ctx</code> variables.</p><table tabindex="0"><thead><tr><th>Variable</th><th>Functionality</th><th>Details</th></tr></thead><tbody><tr><td><code>ctx.caller</code></td><td>The identity of the person or smart contract calling the function.</td><td>Changes when a new function is evoked to the name of the smart contract that evoked that function. This allows for gating.</td></tr><tr><td><code>ctx.this</code></td><td>The identity of the smart contract where this variable is used.</td><td>Constant. Never changed. Use for giving smart contracts rights and accounts.</td></tr><tr><td><code>ctx.signer</code></td><td>The top-level signer of the transaction. This is constant throughout the transaction&#39;s execution</td><td></td></tr><tr><td><code>ctx.owner</code></td><td>The owner of the contract, which is an optional field that can be set on time of submission.</td><td>If this field is set, only the <code>ctx.owner</code> can call any of the functions on the smart contract. This allows for a parent-child model.</td></tr><tr><td><code>ctx.entry</code></td><td>The entry function and contract as a tuple.</td><td>ctx.entry can help you distinguish a caller (either user or contract) and if the caller is a contract, it will inform you about the method from which that contract called your contract.</td></tr><tr><td><code>ctx.submission_name</code></td><td>The name of the submission contract, usually &#39;submission&#39;.</td><td></td></tr></tbody></table><h2 id="ctx-caller" tabindex="-1">ctx.caller <a class="header-anchor" href="#ctx-caller" aria-label="Permalink to &quot;ctx.caller&quot;">​</a></h2><p>This is the most complex Context variable, but also the most useful. The ctx.caller is the same as the transaction signer (ctx.signer) at the beginning of execution. If the smart contract that is initially invoked calls a function on another smart contract, the ctx.caller then changes to the name of the smart contract calling that function, and so on and so forth until the end of the execution.</p><p>direct.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> who_am_i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.caller</span></span></code></pre></div><p>indirect.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> direct</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> call_direct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> direct.who_am_i()</span></span></code></pre></div><p>Assume the two contracts above exist in state space. If <code>stu</code> calls <code>who_am_i</code> on the <code>direct</code> contract, <code>stu</code> will be returned because <code>direct</code> does not call any functions in any other smart contracts.</p><p>However, if <code>stu</code> calls <code>call_direct</code> on the <code>indirect</code> contract, <code>indirect</code> will be returned because <code>indirect</code> is now the caller of this function.</p><p>A good example of how to use this would be in a token contract.</p><p>token.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">balances </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Hash()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@construct</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> seed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    balances[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;stu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    balances[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;contract&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(amount, to):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> balances[ctx.caller] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    balances[ctx.caller] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    balances[to] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount</span></span></code></pre></div><p>contract.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> withdraw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(amount):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.caller </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;stu&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    token.send(amount, ctx.caller)</span></span></code></pre></div><p>In the above setup, <code>stu</code> has 100 tokens directly on the <code>token</code> contract. He can send them, because his account balance is looked up based on the <code>ctx.caller</code> when the send function is called.</p><p>Similarly, <code>contract</code> also has 99 tokens. When <code>contract</code> imports <code>token</code> and calls <code>send</code>, <code>ctx.caller</code> is changed to <code>contract</code>, and its balance is looked up and mutated accordingly.</p><h3 id="ctx-this" tabindex="-1">ctx.this <a class="header-anchor" href="#ctx-this" aria-label="Permalink to &quot;ctx.this&quot;">​</a></h3><p>This is a very simple reference to the name of the smart contract. Use cases are generally when you need to identify a smart contract itself when doing some sort of transaction, such as sending payment through an account managed by the smart contract but residing in another smart contract.</p><p>registrar.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Hash()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, value):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> names[name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        names[name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span></code></pre></div><p>controller.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> registrar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    registrar.register(ctx.this, value)</span></span></code></pre></div><h2 id="ctx-signer" tabindex="-1">ctx.signer <a class="header-anchor" href="#ctx-signer" aria-label="Permalink to &quot;ctx.signer&quot;">​</a></h2><p>This is the absolute signer of the transaction regardless of where the code is being executed in the call stack. This is good for creating blacklists of users from a particular contract.</p><p>blacklist.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">not_allowed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;stu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;tejas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.signer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">not</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> not_allowed</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;You are not blacklisted!&#39;</span></span></code></pre></div><p>indirect.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blacklist</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> try_to_bypass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> blacklist.some_func()</span></span></code></pre></div><p>In the case that <code>stu</code> calls the <code>try_to_bypass</code> function on <code>indirect</code>, the transaction will still fail because <code>ctx.signer</code> is used for gating instead of <code>ctx.caller</code>.</p><p><strong>NOTE</strong>: Never use <code>ctx.signer</code> for account creation or identity. Only use it for security guarding and protection. <code>ctx.caller</code> should allow behavior based on the value. <code>ctx.signer</code> should block behavior based on the value.</p><h3 id="ctx-owner" tabindex="-1">ctx.owner <a class="header-anchor" href="#ctx-owner" aria-label="Permalink to &quot;ctx.owner&quot;">​</a></h3><p>On submission, you can specify the owner of a smart contract. This means that only the owner can call the <code>@export</code> functions on it. This is for advanced contract pattern types where a single controller is desired for many &#39;sub-contracts&#39;. Using <code>ctx.owner</code> inside of a smart contract can only be used to change the ownership of the contract itself. Be careful with this method!</p><p>ownable.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> change_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(new_owner):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx.owner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new_owner</span></span></code></pre></div><p>The above contract is not callable unless the <code>ctx.caller</code> is the <code>ctx.owner</code>. Therefore, you do not need to do additional checks to make sure that this is the case.</p><h2 id="ctx-entry" tabindex="-1">ctx.entry <a class="header-anchor" href="#ctx-entry" aria-label="Permalink to &quot;ctx.entry&quot;">​</a></h2><p>When someone calls a contract through another contract, you might want to know what contract and function it was that called it in the first place.</p><p><code>ctx.entry</code> returns a tuple containing the name of the contract and the function that was called.</p><p>contract.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.entry  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Output when someone used other_contract: (&quot;other_contract&quot;,&quot;call_contract&quot;)</span></span></code></pre></div><p>other_contract.py (Smart Contract)</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contract</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@export</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> call_contract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contract.function()</span></span></code></pre></div>`,44);function g(a,y,E,u,m,b){return l(),e("div",null,[s("h1",p,[t(i(a.$frontmatter.title)+" ",1),c]),s("h2",r,[t(i(a.$frontmatter.description)+" ",1),d]),k])}const x=n(o,[["render",g]]);export{F as __pageData,x as default};
